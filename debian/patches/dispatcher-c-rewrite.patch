Index: usb-modeswitch/usb_modeswitch_dispatcher.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ usb-modeswitch/usb_modeswitch_dispatcher.c	2011-08-09 12:32:18.318143199 -0400
@@ -0,0 +1,1918 @@
+/*
+  Mode switching tool for controlling flip flop (multiple device) USB gear
+  Version 0.0.1, 2011/07/14 by Mathieu Trudel-Lapierre <mathieu@canonical.com>
+
+  Created with initial help from:
+    "usb_modeswitch.tcl" by Joshua Dietze
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details:
+
+  http://www.gnu.org/licenses/gpl.txt
+
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <libgen.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <regex.h>
+#include <dirent.h>
+#include <pipeline.h>
+#include <libudev.h>
+#include <time.h>
+#include <glob.h>
+#include <syslog.h>
+
+#define BIND_LIST "/var/lib/usb_modeswitch/bind_list"
+#define LOGFILE_TEMPL "/var/log/usb_modeswitch.log"  /* will be suffixed with a device ID */
+#define DB_DIR "/usr/share/usb_modeswitch"
+#define DB_ETCDIR "/etc/usb_modeswitch.d"
+#define BIN_DIR "/usr/sbin"
+#define DEV_DIR_BASE "/sys/bus/usb/devices"
+#define DEFAULT_TMPCONFIG "/var/lib/usb_modeswitch/current_cfg"
+#define CONFIG_PACK_NAME "configPack.tar.gz"
+
+struct list_entry {
+	char *data;
+	struct list_entry *next;
+};
+
+struct conf_data {
+	char *dev_dir;
+
+	char *config_pack_path;
+	char *config_name;
+	char *config_param;
+
+	char *device_config;
+
+	char *driver_id_path;
+	char *driver_module;
+	int wait_before;
+
+	char **config_list;
+};
+
+struct dev_attr {
+	char *attr;
+	char *value;
+};
+
+/* SCSI Vendor   */
+#define sVe 0
+
+/* SCSI Model    */
+#define sMo 1
+
+/* SCSI Revision */
+#define sRe 2
+
+/* USB idVendor */
+#define idVendor 0
+/* USB idProduct */
+#define idProduct 1
+/* USB bNumConfigurations */
+#define bNumConfigurations 5
+
+/* USB Manufacturer */
+#define uMa 2
+
+/* USB Product name */
+#define uPr 3
+
+/* USB Serial No.   */
+#define uSe 4
+
+const char *config_places[] = {
+		"/etc/usb_modeswitch.conf",
+		"/etc/sysconfig/usb_modeswitch",
+		"/etc/default/usb_modeswitch",
+		NULL};
+
+#define NUM_SCSI_ATTRS 3 /* always define to number of items in list below (minus NULL) */
+const char *scsi_attrs[] = {
+		"vendor",
+		"model",
+		"rev",
+		NULL };
+
+#define NUM_USB_ATTRS 6  /* always define to number of items in list below (minus NULL) */
+const char *usb_attrs[] = {
+		"idVendor",
+		"idProduct",
+		"manufacturer",
+		"product",
+		"serial",
+		"bNumConfigurations",
+		NULL };
+
+int logging = 0;
+int noswitching = 0;
+
+FILE *logfile = NULL;
+char* device = NULL;
+char* config_file = NULL;
+struct conf_data config;
+struct dev_attr *scsi[NUM_SCSI_ATTRS];
+struct dev_attr *usb[NUM_USB_ATTRS];
+
+char* substring(const char* str, size_t begin, size_t len);
+char* rtrim(char *s);
+void free_list(struct list_entry *list);
+char* join_path(char *base_path, char *add_path);
+int parse_global_config();
+int has_interrupt (char* if_dir);
+char* symlink_name (char* path);
+void check_driver_bind (char* vid, char* pid);
+int parse_device_config(char *device_config);
+struct list_entry* list_serial_devs();
+void remove_from_bind_list (char *id);
+int add_to_list (char* name, char *id);
+int in_bind_list (char *id);
+void modeswitch_log(const char* format, ...);
+void read_attrs(char *subsystem, struct dev_attr **dev_type, char **attr_list, char *dir);
+void read_scsi_attrs(char *dir);
+void read_usb_attrs(char *dir);
+void config_get_list(char *config_name);
+char* config_get_config(char *config_name);
+int match_device(char *config_name);
+int read_pipeline (pipeline *p, int logging, int* no_driver_loading, int* found_ok);
+int count_in_list_entry (struct list_entry *list, char *search);
+
+int main(int argc, char* argv[])
+{
+	regex_t reg;
+	regmatch_t match[3];
+	char *val, *tmpval, *tmp;
+	char bus_id[PATH_MAX], *kernel_name = NULL;
+	char dev_top[PATH_MAX];
+	char *udev_args = NULL;
+	char *msg;
+	char *sys_dir;
+	char *fname;
+	char *selected_config;
+	char line[PATH_MAX];
+	int i;
+	int scsi_needed;
+	int no_data;
+	int counter;
+	int no_driver_loading;
+	int found_ok;
+	pipeline *p;
+	struct timespec sleep_500;
+	FILE *rc;
+	glob_t path_glob;
+	int glob_status;
+	struct list_entry *dev_list, *dev_list2;
+
+	sleep_500.tv_sec = 0;  				// 0 seconds...
+	sleep_500.tv_nsec = 500000000l;		// ... plus .5 seconds.
+
+	/*
+	 * The facility to add a symbolic link pointing to the
+	 * ttyUSB port which provides interrupt transfer, i.e.
+	 * the port to connect through; returns a symlink name
+	 * for udev and exits.
+	 * This is run once for every known device interface by
+	 * an udev rule.
+	 */
+
+	if (argc > 1 && strcmp(argv[1], "--symlink-name") == 0 ) {
+
+		if ((val = symlink_name(argv[2])) != NULL)
+				puts(val);
+		else
+			_exit(1);
+
+		_exit(0);
+	}
+	else if (argc < 2) {
+		printf("Too few arguments. This program should only be called from udev.\n");
+		_exit(1);
+	}
+
+	parse_global_config();
+
+	if (access(DB_DIR, X_OK) != 0 && access(DB_ETCDIR, X_OK) != 0) {
+		modeswitch_log("Error: no config database found in /usr/share or /etc. Exiting.\n");
+		return 1;
+	}
+
+	openlog("usb_modeswitch", LOG_PID, LOG_DAEMON);
+
+	/*
+	 * udev_args (argv[1]) contains the values provided from the udev rule separated by "/"
+	 */
+	udev_args = argv[1];
+	if (!udev_args) {
+		modeswitch_log("No data from udev. Exiting\n");
+		return 1;
+	}
+	else
+		modeswitch_log("Raw args from udev: %s\n\n", udev_args);
+
+	/*
+	 * arg 0: the bus id for the device (udev: %b)
+	 * arg 1: the "kernel name" for the device (udev: %k)
+	 *
+	 * Both together give the top directory where the path
+	 * to the SCSI attributes can be determined (further down)
+	 * Addendum: older kernel/udev version seem to differ in
+	 * providing these attributes - or not. So more probing
+	 * is needed.
+	 */
+	kernel_name = strchr(udev_args, '/') + 1;
+
+	strncpy (bus_id, udev_args, strlen(udev_args) - strlen(kernel_name) - 1);
+	bus_id[strlen(bus_id)] = '\0';
+
+	if (strlen(kernel_name) > 0 && strlen(bus_id) == 0) {
+		char *colon = strchr (kernel_name, ':');
+
+		modeswitch_log("Bus ID for device not given by udev.\n");
+		modeswitch_log(" Trying to determine it from kernel name (%s) ...\n", kernel_name);
+
+		if (colon) {
+			strncpy (dev_top, kernel_name, strlen(kernel_name) - strlen(colon));
+			dev_top[strlen(dev_top)] = '\0';
+		}
+	}
+	else if (strlen(bus_id) > 0) {
+		strcpy(dev_top, bus_id);
+	}
+	else {
+		modeswitch_log("No device number values given from udev! Exiting.\n");
+		return 1;
+	}
+
+	if (!*dev_top) {
+		modeswitch_log("Could not determine top device dir from udev values! Exiting.\n");
+		return 1;
+	}
+
+	asprintf(&config.dev_dir, "%s/%s", DEV_DIR_BASE, dev_top);
+	if (access(config.dev_dir, X_OK) != 0) {
+		modeswitch_log("Top sysfs directory not found (%s)! Exiting.\n", config.dev_dir);
+		return 1;
+	}
+
+	/* Now reading the USB attributes */
+	read_usb_attrs(config.dev_dir);
+
+	/* also "read" scsi to initialize the data structures at least to empty strings */
+	read_scsi_attrs(config.dev_dir);
+
+	if (strlen(usb[idVendor]->value) + strlen(usb[idProduct]->value) < 8) {
+		modeswitch_log("USB IDs not found in sysfs tree. Exiting.\n");
+		return 1;
+	}
+
+	modeswitch_log("----------------\nUSB values from sysfs:\n");
+	for (i = 0; i < NUM_USB_ATTRS; i++) {
+		modeswitch_log("  %s\t%s\n", usb[i]->attr, usb[i]->value);
+	}
+	modeswitch_log("----------------\n");
+
+	if (noswitching) {
+		modeswitch_log("\nSwitching globally disabled. Exiting.\n");
+		syslog(LOG_NOTICE, "usb_modeswitch: switching disabled, no action for %s:%s",
+		       usb[0]->value, usb[1]->value);
+		return 0;
+	}
+
+	if (strcmp(usb[bNumConfigurations]->value, "1") == 0) {
+		config.config_param = strdup("-u -1");
+		modeswitch_log("bNumConfigurations is 1 - don't check for active configuration\n");
+	}
+	else {
+		config.config_param = 0;
+	}
+
+	/*
+	 * Retrieve the full list of available configurations from the config pack,
+	 * but also look for files matching the USB ID name in config directories,
+	 * in /usr/share/usb-modeswitch and /etc/usb-modeswitch.d.
+	 *
+	 * Check if there is more than one config file for this USB ID,
+	 * which would make an attribute test necessary. If so, check if
+	 * SCSI values are needed.
+	 */
+	asprintf(&config.config_name, "%s:%s", usb[idVendor]->value, usb[idProduct]->value);
+	config_get_list(config.config_name);
+
+	if (config.config_list == NULL) {
+		modeswitch_log("Aargh! Config file missing for $usb(idVendor):$usb(idProduct)! Exiting.\n");
+		return 1;
+	}
+
+	/*
+	 * Look through the list of possible configurations available to find
+	 * the last to match. This is to make sure we get an overriding config
+	 * if one exists, or at least a config directly from the tarball.
+	 * If nothing matches, the config_name is a new device that nothing else
+	 * defines (the pack of configs, or files in /usr/share, or in /etc...
+	 */
+	selected_config = NULL;
+	for (i = 0; config.config_list[i] != NULL; i++) {
+		if (strstr(config.config_list[i], config.config_name) != NULL) {
+			selected_config = config.config_list[i];
+		}
+	}
+
+	scsi_needed = 0;
+	int len = strlen (selected_config);
+	if (selected_config[len - 2] == ':' &&
+	    selected_config[len - 1] == 's')
+		scsi_needed = 1;
+
+	if (!scsi_needed)
+		modeswitch_log("SCSI attributes not needed, moving on.\n");
+
+	/*
+	 * Getting the SCSI values via libusb results in a detached
+	 * usb-storage driver. Not good for devices that want to be
+	 * left alone. Fortunately, the sysfs tree provides the values
+	 * too without need for direct access
+	 *
+	 * First we wait until the SCSI data is ready - or timeout.
+	 * Timeout means: no storage driver was bound to the device.
+	 * We run 20 times max, every half second (max. 10 seconds
+	 * total)
+	 *
+	 * We also check if the device itself changes, probably
+	 * because it was switched by the kernel (or even unplugged).
+	 * Then we do simply nothing and exit quietly ...
+	 */
+
+	i = 0;
+	while (scsi_needed == 1 && i < 20) {
+		nanosleep(&sleep_500, NULL);
+		i++;
+		modeswitch_log("waiting for storage tree in sysfs\n");
+
+		asprintf(&sys_dir, "%s/%s", config.dev_dir, kernel_name);
+		if (access(sys_dir, X_OK) != 0) {
+			/* Device is gone. Unplugged? Switched by kernel? */
+			modeswitch_log("sysfs device tree is gone; exiting.\n");
+			return 1;
+		}
+
+		asprintf(&fname, "%s/product", config.dev_dir);
+
+		if (access(fname, F_OK) == 0) {
+			modeswitch_log("file name exists: %s\n", fname);
+		}
+		else {
+			modeswitch_log("file name not readable: %s\n", fname);
+			continue;
+		}
+
+		rc = fopen(fname, "r");
+		fgets(line, PATH_MAX, rc);
+		val = strdup(rtrim(line));
+		fclose(rc);
+
+		if (strcmp(val, usb[uPr]->value) != 0) {
+			/* Device has just changed. Switched by someone else? */
+			modeswitch_log("device has changed; exiting.\n");
+			return 0;
+		}
+		free(val);
+
+		/* Searching the storage/SCSI tree; might take a while.
+		 * The SCSI tree in sysfs needs to all be there, so we'll slowly
+		 * get through each of the subdirectories checking for existence:
+		 * first the /sys/devices/xxx/host* directory; then its target*
+		 * subdirectory. Only ever the first subdirectory with that name,
+		 * for USB modems they shouldn't have more anyway.
+		 */
+		asprintf(&val, "%s/host*", sys_dir);
+		glob_status = glob(val, 0, NULL, &path_glob);
+		if (glob_status == 0 && path_glob.gl_pathv[0] != NULL) {
+			asprintf(&sys_dir, "%s/target*", path_glob.gl_pathv[0]);
+			globfree(&path_glob);
+			free(val);
+			glob_status = glob(sys_dir, 0, NULL, &path_glob);
+			if (glob_status == 0 && path_glob.gl_pathv[0] != NULL) {
+				if (strstr(path_glob.gl_pathv[0], "target") != NULL) {
+					asprintf(&sys_dir, "%s/*", path_glob.gl_pathv[0]);
+					globfree(&path_glob);
+					glob_status = glob(sys_dir, 0, NULL, &path_glob);
+					if (glob_status == 0 && path_glob.gl_pathv[0] != NULL) {
+						asprintf(&val, "%s/vendor", path_glob.gl_pathv[0]);
+						free(sys_dir);
+						asprintf(&sys_dir, "%s", path_glob.gl_pathv[0]);
+						if (access(val, F_OK) == 0) {
+							/* Finally SCSI structure is ready, get the values */
+							read_scsi_attrs(sys_dir);
+							break;
+						}
+					}
+					globfree(&path_glob);
+				}
+			}
+			else
+				globfree(&path_glob);
+		}
+		else
+			globfree(&path_glob);
+	}
+
+	if (scsi_needed) {
+		if (i == 20 && strlen(scsi[sVe]->value) == 0) {
+			modeswitch_log("SCSI tree not found; you may want to check if this path/file exists:\n");
+			modeswitch_log("%s/vendor\n", sys_dir);
+		}
+		else {
+			modeswitch_log("----------------\nSCSI values from sysfs:");
+			modeswitch_log(" vendor\t%s\n", scsi[sVe]->value);
+			modeswitch_log(" model\t%s\n", scsi[sMo]->value);
+			modeswitch_log(" revision\t%s\n", scsi[sRe]->value);
+			modeswitch_log("----------------\n");
+		}
+		modeswitch_log("Waiting 3 secs. after SCSI device was added.\n");
+		sleep(3);
+	}
+	else {
+		nanosleep(&sleep_500, NULL);
+	}
+
+	/*
+	 * If SCSI tree in sysfs was not identified, try and get the values
+	 * from a (nonswitching) call of usb_modeswitch; this detaches the
+	 * storage driver, so it's just the last resort.
+	 */
+	if (scsi_needed && strcmp(scsi[sVe]->value, "") == 0) {
+		char *hex_vendor, *hex_product;
+		char *attr_name, *attr_val;
+		const char *line2;
+
+		asprintf(&hex_vendor, "0x%s", usb[idVendor]->value);
+		asprintf(&hex_product, "0x%s", usb[idProduct]->value);
+		asprintf(&tmpval, "%s/usb_modeswitch", BIN_DIR);
+		p = pipeline_new_command_args (tmpval,
+                                       "-v", hex_vendor,
+                                       "-p", hex_product,
+                                       "2>/dev/null", NULL);
+		free(tmpval);
+		free(hex_vendor);
+		free(hex_product);
+		pipeline_want_out (p, -1);
+		pipeline_start (p);
+
+		regcomp(&reg, "(Vendor|Model|Revision) String: (.*?)", REG_EXTENDED);
+
+		while ((line2 = pipeline_readline(p)) != NULL) {
+			tmp = rtrim(strdup(line2));
+			if (regexec(&reg, line2, 3, match, 0) == 0) {
+				attr_name = substring(tmp,
+								   match[1].rm_so,
+								   match[1].rm_eo - match[1].rm_so);
+				attr_val = substring(tmp,
+                                   match[2].rm_so,
+                                   match[2].rm_eo - match[2].rm_so);
+
+				i = -1;
+				if (strcmp(attr_name, "Vendor") == 0)
+					i = sVe;
+				else if (strcmp(attr_name, "Model") == 0)
+					i = sMo;
+				else if (strcmp(attr_name, "Revision") == 0)
+					i = sRe;
+
+				if (i != -1) {
+					scsi[i]->attr = strdup(scsi_attrs[i]);
+					scsi[i]->value = attr_val;
+				}
+			}
+		}
+		regfree(&reg);
+
+		modeswitch_log("SCSI values from usb_modeswitch:\n");
+		modeswitch_log(" vendor\t%s\n", scsi[sVe]->value);
+		modeswitch_log(" model\t%s\n", scsi[sMo]->value);
+		modeswitch_log(" revision\t%s\n", scsi[sRe]->value);
+	}
+	modeswitch_log("\n");
+
+	/*
+	 * If we don't have the SCSI values by now, we just
+	 * leave the variables empty; they won't match anything
+	 *
+	 * Time to check for a matching config file.
+	 * Matching itself is done by MatchDevice
+	 *
+	 * Sorting the configuration file names reverse so that
+	 * the ones with matching additions are tried first; the
+	 * common configs without match attributes are used at the
+	 * end and provide a fallback
+	 */
+	selected_config = NULL;
+	for (i = 0; config.config_list[i] != NULL; i++) {
+		if (strstr(config.config_list[i], config.config_name) != NULL &&
+                    match_device(config.config_list[i])) {
+			selected_config = config.config_list[i];
+		}
+		//else
+		//	modeswitch_log("* no match, not switching with this config\n");
+	}
+
+	if (selected_config != NULL) {
+		if (config_get_config (selected_config) != NULL) {
+			parse_device_config (config.device_config);
+			dev_list = list_serial_devs();
+			if (config.wait_before == 0) {
+				modeswitch_log("! matched, now switching\n");
+			}
+			else {
+				modeswitch_log("! matched, waiting time set to %d seconds.\n", config.wait_before);
+				sleep(config.wait_before);
+				modeswitch_log(" waiting is over, switching starts now.\n");
+			}
+
+			/* Now we are actually switching */
+			no_driver_loading = 0;
+			found_ok = 0;
+			asprintf(&msg,
+					"%s/usb_modeswitch -I -W -D -c %s %s 2>&1",
+					BIN_DIR,
+					config.device_config,
+					config.config_param);
+			p = pipeline_new();
+			pipeline_command_argstr (p, msg);
+			pipeline_want_out (p, -1);
+			pipeline_start (p);
+			if (logging) {
+				modeswitch_log(" (running command: %s)\n\n", msg);
+				modeswitch_log("Verbose debug output of usb_modeswitch and libusb follows\n");
+				modeswitch_log("(Note that some USB errors are expected in the process)\n");
+				modeswitch_log("--------------------------------\n");
+			}
+			free(msg);
+			no_data = read_pipeline(p, logging, &no_driver_loading, &found_ok);
+			if (logging) {
+				modeswitch_log("--------------------------------\n");
+				modeswitch_log("(end of usb_modeswitch output)\n");
+			}
+			pipeline_free(p);
+			if (strstr(config.device_config, "current_cfg") != NULL) {
+				unlink(config.device_config);
+			}
+		}
+	}
+	else {
+		modeswitch_log("Aargh! Config file missing for %s! Exiting.\n", config.config_name);
+		return 1;
+	}
+
+	/*
+         * We're finished with switching; success checking
+         * was done by usb_modeswitch and logged via syslog.
+	 *
+	 * If switching was OK we now check for drivers by
+	 * simply recounting serial devices under /dev.
+	 */
+	if (access(config.dev_dir, X_OK) != 0) {
+		modeswitch_log("Device directory in sysfs is done! Something went wrong, aborting.\n");
+		return 1;
+	}
+
+	/* Give the device another second if it's not fully back yet. */
+	asprintf(&fname, "%s/idProduct", config.dev_dir);
+	if (access(fname, F_OK) != 0) {
+		sleep(1);
+		if (access(fname, F_OK) != 0)
+			sleep(1);
+	}
+
+	if (access(fname, F_OK) == 0) {
+		read_usb_attrs(config.dev_dir);
+	}
+
+	if (found_ok == 1) {
+		if(strlen(usb[idVendor]->value) > 4 &&
+		   strlen(usb[idProduct]->value) > 4 &&
+		   strcmp(usb[idVendor]->value, "0000") != 0 &&
+		   strcmp(usb[idProduct]->value, "0000") != 0) {
+			if (no_data)
+				modeswitch_log("Libusb1 bug prevented device searching, and device ID not found afterwards.\n");
+			modeswitch_log("No vendor/product ID found or given, can't continue. Aborting.\n");
+			return 1;
+		}
+
+		/*
+		 * For general driver loading; TODO: add respective device names.
+		 * Presently only useful for HSO devices (which are recounted now).
+		 */
+		if (!config.driver_module || strlen(config.driver_module) == 0) {
+			asprintf(&config.driver_module, "option");
+			asprintf(&config.driver_id_path, "/sys/bus/usb-serial/drivers/option1");
+		}
+		else {
+			if (!config.driver_id_path || strlen(config.driver_id_path) == 0)
+				asprintf(&config.driver_id_path, "/sys/bus/usb/drivers/%s", config.driver_module);
+		}
+		modeswitch_log("Driver module is \"%s\", ID PATH is %s\n", config.driver_module, config.driver_id_path);
+
+		/* some settling time in ms (500ms) */
+		nanosleep(&sleep_500, NULL);
+
+		modeswitch_log("Now checking for newly created serial devices ...\n");
+		dev_list2 = list_serial_devs();
+
+		if (count_in_list_entry(dev_list, "") >= count_in_list_entry(dev_list2, "")) {
+			modeswitch_log(" no new serial devices found\n");
+
+			add_to_list("link_list", config.config_name);
+
+			/* If device is known, the sh wrapper will take care, else: */
+			if (in_bind_list(config.config_name) == 0) {
+				modeswitch_log("Device not in bind_list\n");
+
+				/* load driver */
+				check_driver_bind(usb[idVendor]->value, usb[idProduct]->value);
+				counter = 0;
+
+				/* Old/slow systems may take a while to create the devices */
+				while (count_in_list_entry(dev_list, "") >= count_in_list_entry(dev_list2, "")
+						&& counter < 14) {
+					nanosleep(&sleep_500, NULL);
+					dev_list2 = list_serial_devs();
+					counter++;
+				}
+				if (counter == 14) {
+					modeswitch_log(" still no new serial devices found\n");
+				}
+				else {
+					modeswitch_log(" driver successfully bound\n");
+					add_to_list("bind_list", config.config_name);
+				}
+			}
+		}
+		else {
+			modeswitch_log(" new serial devices found, driver has bound\n");
+			if (count_in_list_entry(dev_list2, "ttyUSB") > count_in_list_entry(dev_list, "ttyUSB")) {
+				add_to_list("link_list", config.config_name);
+			}
+		}
+	}
+	else {
+		/* Just in case "NoDriverLoading" was added after the first bind */
+		remove_from_bind_list (config.config_name);
+	}
+
+	if (no_driver_loading == 1) {
+		/* "NoDriverLoading" was set */
+		modeswitch_log("Doing no driver checking or binding for this device\n");
+	}
+
+	/*
+	 * In newer kernels there is a switch to avoid the use of a device
+	 * reset (e.g. from usb-storage) which would likely switch back
+	 * a mode-switching device.
+	 */
+	if (found_ok == 1) {
+		modeswitch_log("Checking for AVOID_RESET_QUIRK attribute\n");
+		asprintf(&fname, "%s/avoid_reset_quirk", config.dev_dir);
+		if (access(fname, F_OK) == 0) {
+			int fd = open(fname, O_WRONLY);
+			if (fd < 0)
+				perror("Error opening quirk file:");
+			if (write(fd, "1", 1) > 0)
+				modeswitch_log(" AVOID_RESET_QUIRK activated\n");
+			else
+				perror(" Error setting the attribute:");
+		}
+		else
+			modeswitch_log(" AVOID_RESET_QUIRK not present\n");
+	}
+
+	modeswitch_log("\nAll done, exiting\n\n");
+
+	return 0;
+}
+
+int count_in_list_entry (struct list_entry *list, char *search) {
+
+	struct list_entry *node;
+	int count = 0;
+
+	node = list;
+	while (node != NULL && node->data != NULL) {
+		if (strstr (node->data, search) == 0)
+			count++;
+		node = node->next;
+	}
+
+	return count;
+}
+
+int read_pipeline (pipeline *p, int logging, int* no_driver_loading, int* found_ok)
+{
+	regex_t reg_ids, reg_nodata, reg_ndl;
+	regmatch_t *match;
+	const char *tmp;
+	char *tmpval;
+	int no_data = 0;
+
+	regcomp(&reg_ids, "ok:([0-9a-f]{4}):([0-9a-f]{4})", REG_EXTENDED | REG_ICASE);
+	regcomp(&reg_nodata, "ok:no_data", REG_EXTENDED | REG_ICASE);
+	regcomp(&reg_ndl, "ok:$", REG_EXTENDED | REG_ICASE);
+	match = malloc(sizeof(*match) * 3);
+
+	while ((tmp = pipeline_readline(p)) != NULL) {
+		if (regexec(&reg_ids, tmp, 3, match, 0) == 0) {
+			tmpval = substring(tmp,
+					   match[1].rm_so,
+					   match[1].rm_eo - match[1].rm_so);
+			usb[idVendor]->value = strdup(tmpval);
+			tmpval = substring(tmp,
+					   match[2].rm_so,
+					   match[2].rm_eo - match[2].rm_so);
+			usb[idProduct]->value = strdup(tmpval);
+			*found_ok = 1;
+		}
+		if (regexec(&reg_nodata, tmp, 0, NULL, 0) == 0) {
+			no_data = 1;
+			*found_ok = 1;
+		}
+		if (regexec(&reg_ndl, tmp, 0, NULL, 0) == 0) {
+			*no_driver_loading = 1;
+			*found_ok = 1;
+		}
+
+		if (logging)
+			modeswitch_log("%s", tmp);
+	}
+
+	regfree(&reg_ids);
+	regfree(&reg_nodata);
+	regfree(&reg_ndl);
+	free(match);
+
+	return no_data;
+}
+
+char* substring(const char* str, size_t begin, size_t len)
+{
+	if (str == 0 || strlen(str) == 0 || strlen(str) < begin || strlen(str) < (begin+len))
+		return 0;
+
+	return strndup(str + begin, len);
+}
+
+char* rtrim(char *s)
+{
+    char* back = s + strlen(s);
+
+    while(isspace(*--back));
+
+    *(back+1) = '\0';
+
+    return s;
+}
+
+void free_list(struct list_entry *list)
+{
+	struct list_entry *entry, *copy;
+
+	entry = list;
+	while(entry != NULL && entry->data != NULL) {
+		copy = entry->next;
+		free(entry->data);
+		free(entry);
+		entry = copy;
+	}
+
+	return;
+}
+
+char* join_path(char *base_path, char *add_path)
+{
+	char *cleanpath = malloc(PATH_MAX);
+	char *token;
+
+	memset(cleanpath, '\0', 1);
+
+	token = strtok(base_path, "/");
+	while (token != NULL) {
+		if (strcmp(token, "..") == 0) {
+			token = strtok(NULL, "/");
+			continue;
+		}
+		else {
+			strcat(cleanpath, "/");
+			strcat(cleanpath, token);
+		}
+		token = strtok(NULL, "/");
+	}
+	token = NULL;
+
+	token = strtok(add_path, "/");
+	while (token != NULL) {
+		if (strcmp(token, "..") == 0) {
+			cleanpath = dirname(strdup(cleanpath));
+			token = strtok(NULL, "/");
+			continue;
+		}
+		else {
+			strcat(cleanpath, "/");
+			strcat(cleanpath, token);
+		}
+		token = strtok(NULL, "/");
+	}
+	return cleanpath;
+}
+
+int parse_global_config()
+{
+
+	char* temp_val;
+	char line[PATH_MAX];
+	int i, j;
+	FILE *rc;
+	regex_t disable_switching_re, enable_logging_re;
+	regmatch_t *disable_switching_m = NULL, *enable_logging_m = NULL;
+
+	for ( i = 0; config_places[i] != NULL; i++) {
+		j = access(config_places[i], F_OK);
+		if (j == 0) {
+			config_file = strdup(config_places[i]);
+			break;
+		}
+	}
+
+	if (config_file == NULL) {
+		perror("no config file readable");
+		return 1;
+	}
+
+	rc = fopen(config_file, "r");
+
+	if (regcomp(&disable_switching_re, "^DisableSwitching[[:space:]]*=[[:space:]]*([^[:space:]]+)", REG_EXTENDED) != 0) {
+		return 1;
+	}
+
+	if (regcomp(&enable_logging_re, "^EnableLogging[[:space:]]*=[[:space:]]*([^[:space:]]+)", REG_EXTENDED) != 0) {
+		regfree (&disable_switching_re);
+		return 1;
+	}
+
+	disable_switching_m = malloc(sizeof(*disable_switching_m)*2);
+	enable_logging_m = malloc(sizeof(*disable_switching_m)*2);
+
+	while (fgets(line, PATH_MAX, rc) != NULL) {
+		if (regexec(&disable_switching_re, line, 2, disable_switching_m, 0) == 0) {
+			temp_val = substring(line,
+						disable_switching_m[1].rm_so,
+						disable_switching_m[1].rm_eo - disable_switching_m[1].rm_so);
+			noswitching = atoi(temp_val);
+			free(temp_val);
+		}
+		if (regexec(&enable_logging_re, line, 2, enable_logging_m, 0) == 0) {
+			temp_val = substring(line,
+						enable_logging_m[1].rm_so,
+						enable_logging_m[1].rm_eo - enable_logging_m[1].rm_so);
+			logging = atoi(temp_val);
+			free(temp_val);
+		}
+	}
+	fclose (rc);
+
+	regfree(&disable_switching_re);
+	regfree(&enable_logging_re);
+	free(disable_switching_m);
+	free(enable_logging_m);
+
+	modeswitch_log("Using global config file: %s\n\n", config_file);
+
+	return 0;
+}
+
+int has_interrupt (char* if_dir)
+{
+	DIR *dir;
+	FILE *dev_type;
+	struct dirent *ent;
+	int found_tty = 0, ret_val = 0;
+	char *fname = NULL, line[PATH_MAX];
+
+	dir = opendir (if_dir);
+	if (dir != NULL) {
+		while ((ent = readdir (dir)) != NULL) {
+			if (strncmp (ent->d_name, "ttyUSB", 6)) {
+				found_tty = 1;
+				break;
+			}
+		}
+		closedir (dir);
+
+		dir = NULL;
+		dir = opendir (if_dir);
+		if (dir != NULL && found_tty == 1) {
+			while ((ent = readdir (dir)) != NULL) {
+				if (strncmp (ent->d_name, "ep_", 3)) {
+					asprintf(&fname, "%s/%s/type", if_dir, ent->d_name);
+					dev_type = fopen(fname, "r");
+					free (fname);
+					if (dev_type != NULL) {
+						while (fgets(line, PATH_MAX, dev_type) != NULL) {
+							if (strstr(line, "Interrupt")) {
+								modeswitch_log("\n %s has interrupt transfer type\n", if_dir);
+								ret_val = 1;
+								break;
+							}
+						}
+						/*R: break-before-close fd leak */
+						fclose (dev_type);
+					}
+				}
+				if (ret_val == 1) {
+					break;
+				}
+			}
+		}
+		else {
+			ret_val = 0;
+		}
+		closedir (dir);
+	}
+	else {
+		//perror ("");
+		ret_val = -1;
+	}
+
+	return ret_val;
+}
+
+/*R: review done until here */
+
+/* Checking for interrupt endpoint in ttyUSB port (lowest if there is
+ * more than one); if found, check for unused "gsmmodem[n]" name.
+ * Link for first modem will be "gsmmodem", then "gsmmodem2" and up
+ */
+char* symlink_name (char* path)
+{
+	char rawpath_buf[PATH_MAX], dev_rawpath_buf[PATH_MAX];
+	char msg[PATH_MAX], *dev_linkpath, *linkpath, *trimpath, *cleanpath;
+	char re_str[PATH_MAX];
+	char *dev_top, *if_root, *if_dir;
+	char *symlink_name, *symlink_basename;
+	char *token, *w_token, *dev_dir;
+	int my_if;
+	int seen = 0;
+	int n_chars, right_port, i, idx, x;
+	struct stat buf;
+	regex_t re;
+	regmatch_t *match;
+
+	sprintf(msg, "* called with --symlink-name: params %s *\n", path);
+	// TODO: change to a LOG.
+	modeswitch_log("%s\n", msg);
+
+	// In case the device path is returned as /class/tty/ttyUSB,
+	// we need to extract the USB device path from symlink "device"
+	asprintf(&linkpath, "/sys%s", path);
+	asprintf(&dev_linkpath, "/sys%s/device", path);
+	x = lstat (linkpath, &buf);
+	if (x == 0) {
+		if (S_ISLNK (buf.st_mode)) {
+			n_chars = readlink (linkpath, rawpath_buf, PATH_MAX);
+			rawpath_buf[n_chars] = '\0';
+			n_chars = readlink (dev_linkpath, dev_rawpath_buf, PATH_MAX);
+			dev_rawpath_buf[n_chars] = '\0';
+			if (n_chars > 0) {
+				trimpath = basename ((char*)dev_rawpath_buf);
+			}
+		}
+	}
+	else
+		perror("");
+
+	cleanpath = join_path((char*)rawpath_buf, (char*)dev_rawpath_buf);
+
+	if (regcomp(&re, "ttyUSB[0-9]+", REG_EXTENDED) != 0) {
+			return NULL;
+	}
+	if (regexec(&re, (char*)cleanpath, 0, NULL, 0) != 0) {
+		modeswitch_log("Could not find port name in path\n %s. Aborting", cleanpath);
+		return NULL;
+	}
+	regfree(&re);
+
+	device = trimpath;
+	modeswitch_log("My name is %s\n", trimpath);
+
+	//TODO: strip the doubledots off rawpath
+
+	if (regcomp(&re, "usb[0-9]+/([0-9]+-[0-9]+)/", REG_EXTENDED) != 0) {
+			return NULL;
+	}
+	match = malloc(sizeof(*match)*2);
+	if (regexec(&re, cleanpath, 2, match, 0) == 0) {
+		dev_top = substring(cleanpath,
+							match[1].rm_so,
+							match[1].rm_eo - match[1].rm_so);
+	}
+	else {
+		modeswitch_log("Could not find device directory in path\n %s. Aborting", cleanpath);
+		return NULL;
+	}
+	regfree(&re);
+	free(match);
+
+	match = malloc(sizeof(*match)*2);
+	sprintf(re_str, "[0-9]+\\.([0-9]+)/%s", trimpath);
+	if (regcomp(&re, re_str, REG_EXTENDED) != 0) {
+		return NULL;
+	}
+	if (regexec(&re, cleanpath, 2, match, 0) == 0) {
+		my_if = atoi(substring(cleanpath,
+							match[1].rm_so,
+							match[1].rm_eo - match[1].rm_so));
+	}
+	else {
+		modeswitch_log("Could not find interface number in path\n %s. Aborting", cleanpath);
+		return NULL;
+	}
+	regfree(&re);
+	free(match);
+
+	match = malloc(sizeof(*match)*2);
+	sprintf(re_str, "^.*(%s[:/])[0-9]", dev_top);
+	if (regcomp(&re, re_str, REG_EXTENDED) != 0) {
+		return NULL;
+	}
+
+	if (regexec(&re, cleanpath, 2, match, 0) == 0) {
+		if_root = substring(cleanpath,
+							match[0].rm_so,
+							match[0].rm_eo - match[0].rm_so);
+	}
+	else {
+		modeswitch_log("Could not find interface root number in path\n %s. Aborting", cleanpath);
+		return NULL;
+	}
+	regfree(&re);
+	free(match);
+
+	modeswitch_log("\n");
+
+	dev_dir = malloc(PATH_MAX);
+	memset(dev_dir, '\0', 1);
+	token = strtok(strdup(cleanpath), "/");
+	while (token != NULL) {
+		if (strcmp(token, dev_top) == 0) {
+			seen = 1;
+		}
+		w_token = strdup(token);
+		token = strtok(NULL, "/");
+		if (seen == 0) {
+			strcat(dev_dir, "/");
+			strcat(dev_dir, w_token);
+		}
+	}
+
+	modeswitch_log("My port is %s, my interface is %d\n", trimpath, my_if);
+	modeswitch_log(" devDir: %s\n dev_top: %s\n sysPath: %s\n", dev_dir, dev_top, cleanpath);
+	modeswitch_log(" ifRoot: %s\n", if_root);
+
+	asprintf(&if_dir, "/sys%s.%d", if_root, my_if);
+
+	modeswitch_log("\nChecking my endpoints in %s", if_dir);
+	if (has_interrupt(if_dir) == 1) {
+		modeswitch_log("\n--> I am an interrupt port\n");
+		right_port = 1;
+	}
+	else {
+		modeswitch_log("\n--> I am not an interrupt port\n");
+		right_port = 0;
+	}
+
+
+	/* Unfortunately, there are devices with more than one interrupt
+	 * port. The assumption so far is that the lowest of these is
+	 * right. Check all lower interfaces for annother one (if interface)
+	 * is bigger than 0). If found, don't return any name.
+	 */
+	if ( right_port == 1 && my_if > 0 ) {
+		modeswitch_log ("Looking for lower ports with interrupt endpoints");
+		for (i = 0; i < my_if; i++) {
+			sprintf(if_dir, "/sys%s.%d", if_root, i);
+			modeswitch_log (" in ifDir %s ...", if_dir);
+			if (has_interrupt (if_dir) == 1) {
+				modeswitch_log ("\n--> found an interrupt interface below me\n");
+				right_port = 0;
+				break;
+			}
+		}
+	}
+
+	if (right_port == 0) {
+		modeswitch_log ("Return empty name and exit\n");
+		return strdup("");
+	}
+
+	modeswitch_log ("\n--> No interrupt interface below me\n");
+
+	idx = 2;
+	asprintf (&symlink_basename, "gsmmodem");
+	while ( idx < 256 ) {
+		asprintf(&symlink_name, "%s%d", symlink_basename, idx);
+		x = lstat (symlink_name, &buf);
+		if (x != 0)
+			break;
+		free(symlink_name);
+		symlink_name = NULL;
+		idx++;
+	}
+	free (symlink_basename);
+
+	if (symlink_name != NULL) {
+		modeswitch_log ("Return symlink name \"%s\" and exit\n", symlink_name);
+		return symlink_name;
+	}
+	else {
+		return NULL;
+	}
+}
+
+/*
+ *  Load and bind (serial) driver
+ */
+void check_driver_bind (char* vid, char* pid)
+{
+	char *default_loader = "/sbin/modprobe";
+	char *loader = NULL, *id_file;
+	char *vendor_spec, *product_spec;
+	struct stat buf;
+	int i, x, status;
+	pipeline *p;
+	FILE *new_id_f;
+
+	x = lstat (default_loader, &buf);
+	if (x != 0)
+		modeswitch_log (" %s not found", default_loader);
+	else
+		loader = strdup(default_loader);
+
+	asprintf(&id_file, "%s/new_id", config.driver_id_path);
+	x = lstat(id_file, &buf);
+	if (x != 0) {	/* if id_file (new_id file for module) doesn't exist... */
+		if (loader == NULL) {
+			modeswitch_log("Can't do anymore without module loader; get \"modtools\"!\n");
+			return;
+		}
+
+		modeswitch_log("\nTrying to load driver \"%s\"\n", config.driver_module);
+
+		p = pipeline_new_command_args (loader, config.driver_module, NULL);
+		status = pipeline_run(p);
+		if (status != 0) {
+			modeswitch_log(" Running \"%s %s\" gave an error: %d\n", loader, config.driver_module, status);
+			perror("");
+		}
+		else {
+			modeswitch_log(" Driver was loaded successfully: %d\n", status);
+		}
+	}
+	else {
+		modeswitch_log("Driver was loaded already\n");
+	}
+
+	i = 0;
+	while (i < 50) {
+		x = lstat(id_file, &buf);
+		if (x == 0)
+			break;
+		sleep(20);
+		i++;
+	}
+
+	if (i < 50) {
+		modeswitch_log("Trying to add ID to driver \"%s\"\n", config.driver_module);
+		syslog(LOG_NOTICE, "usb_modeswitch: adding device ID %s:%s to driver %s", vid, pid, config.driver_module);
+		new_id_f = fopen(id_file, "a");
+		if (new_id_f != NULL) {
+			if (fprintf(new_id_f, "%s %s", vid, pid) > 0) {
+				modeswitch_log(" ID added to driver; check for new devices in /dev\n");
+			}
+			else {
+				perror("Error adding ID to driver:");
+			}
+		}
+		else {
+			perror ("Couldn't open ID file for writing");
+		}
+	}
+	else {
+		modeswitch_log(" \"%s\" not found, can't add ID to driver;\n check if kernel version is at least 2.6.27\n",
+				id_file);
+		modeswitch_log("Falling back to \"usbserial\"");
+		sprintf(config.driver_module, "usbserial");
+		modeswitch_log("\nTrying to unload driver \"%s\"\n", config.driver_module);
+		p = pipeline_new_command_args (loader, "-r", config.driver_module, NULL);
+		status = pipeline_run (p);
+		if (status != 0) {
+			modeswitch_log(" Running \"%s %s\" gave an error: %d\n", loader, config.driver_module, status);
+			modeswitch_log("Can't unload usbserial. No more fallbacks.\n");
+			return;
+		}
+
+		modeswitch_log("\nTrying to load driver \"usbserial\" with device IDs\n");
+		asprintf(&vendor_spec, "vendor=0x%s", vid);
+		asprintf(&product_spec, "product=0x%s", pid);
+		p = pipeline_new_command_args (loader, "-v usbserial", vendor_spec, product_spec, NULL);
+		free(vendor_spec);
+		free(product_spec);
+		status = pipeline_run (p);
+		if (status != 0) {
+			modeswitch_log(" Running \"%s usbserial\" gave an error:\n %d\n", loader, status);
+		}
+		else {
+			modeswitch_log(" Driver was loaded successfully:\n%d\n", status);
+		}
+	}
+
+	return;
+}
+
+int parse_device_config (char *device_config)
+{
+	char *temp_val = NULL;
+	char line[PATH_MAX];
+	FILE* rc;
+	regex_t module_re, path_re, wb_re;
+	regmatch_t *module_m = NULL, *path_m = NULL, *wb_m = NULL;
+
+	config.driver_module = 0;
+	config.driver_id_path = 0;
+
+	config.wait_before = 0;
+
+	rc = fopen(device_config, "r");
+
+	if (regcomp(&module_re, "^DriverModule[[:space:]]*=[[:space:]]*[[:punct:]]?([[:alnum:]_]*)[[:punct:]]?", REG_EXTENDED) != 0) {
+		return -1;
+	}
+	if (regcomp(&path_re, "^DriverIDPath[[:space:]]*=[[:space:]]*[[:punct:]]?([[:alnum:]_/:-]+)[[:punct:]]?", REG_EXTENDED) != 0) {
+		regfree(&module_re);
+		return -1;
+	}
+	if (regcomp(&wb_re, "^WaitBefore[[:space:]]*=[[:space:]]*([0-9]+)", REG_EXTENDED) != 0) {
+		regfree(&module_re);
+		regfree(&path_re);
+		return -1;
+	}
+
+	module_m = malloc(sizeof(*module_m)*2);
+	path_m = malloc(sizeof(*path_m)*2);
+	wb_m = malloc(sizeof(*wb_m)*2);
+
+	while (fgets(line, PATH_MAX, rc) != NULL) {
+		if (regexec(&module_re, line, 2, module_m, 0) == 0) {
+			temp_val = substring(line,
+									module_m[1].rm_so,
+									module_m[1].rm_eo - module_m[1].rm_so);
+			sprintf(config.driver_module, "%s", temp_val);
+			modeswitch_log("config: DriverModule set to %s\n", config.driver_module);
+		}
+		else if (regexec(&path_re, line, 2, path_m, 0) == 0) {
+			temp_val = substring(line,
+									path_m[1].rm_so,
+									path_m[1].rm_eo - path_m[1].rm_so);
+			sprintf(config.driver_id_path, "%s", temp_val);
+			modeswitch_log("config: DriverIDPath set to %s\n", config.driver_id_path);
+		}
+		else if (regexec(&wb_re, line, 2, wb_m, 0) == 0) {
+			temp_val = substring(line,
+									wb_m[1].rm_so,
+									wb_m[1].rm_eo - wb_m[1].rm_so);
+			config.wait_before = atoi(temp_val);
+			modeswitch_log("config: WaitBefore set to %d\n", config.wait_before);
+		}
+	}
+
+	fclose(rc);
+
+	if (temp_val != NULL)
+		free(temp_val);
+
+	regfree(&module_re);
+	regfree(&path_re);
+	regfree(&wb_re);
+
+	free(module_m);
+	free(path_m);
+	free(wb_m);
+
+	return 1;
+}
+
+struct list_entry* list_serial_devs ()
+{
+	struct udev *udev;
+	struct udev_enumerate *udev_enum;
+	struct udev_list_entry *entry;
+	struct list_entry *dev_list, *dev_list_entry;
+	int enum_status;
+
+	udev = udev_new ();
+	udev_enum = udev_enumerate_new (udev);
+	enum_status = udev_enumerate_add_match_subsystem (udev_enum, "tty");
+
+	/*
+	 * FIXME: might not actually be only USB that we need. Adjust accordingly.
+	 *        In other words, this omits adding devices from /dev/tts:
+	 *        	eval lappend devList [glob -nocomplain /dev/tts/]
+	 *        from the original tcl code.
+	 */
+	enum_status = udev_enumerate_add_match_property (udev_enum, "ID_BUS", "usb");
+
+	enum_status = udev_enumerate_scan_devices (udev_enum);
+	if (enum_status == 0) {
+		dev_list = NULL;
+
+		entry = udev_enumerate_get_list_entry (udev_enum);
+		if (entry != NULL) {
+			dev_list = malloc (sizeof(*dev_list));
+			dev_list->data = strdup(udev_list_entry_get_name (entry));
+		}
+		dev_list_entry = dev_list;
+
+		entry = udev_list_entry_get_next (entry);
+		while (entry != NULL) {
+			dev_list_entry->next = malloc (sizeof(*dev_list_entry));
+			dev_list_entry = dev_list_entry->next;
+			dev_list_entry->data = strdup(udev_list_entry_get_name (entry));
+			entry = udev_list_entry_get_next (entry);
+		}
+
+		if (dev_list_entry != NULL)
+			dev_list_entry->next = NULL;
+
+		return dev_list;
+	}
+	else {
+		return NULL;
+	}
+}
+
+void remove_from_bind_list (char *id)
+{
+	FILE *bind_list_f;
+	char line[PATH_MAX];
+	char *text;
+	struct list_entry *bind_id, *entry, *copy;
+
+	bind_list_f = fopen (BIND_LIST, "r");
+
+	if (bind_list_f != NULL) {
+		bind_id = malloc (sizeof(*bind_id));
+		entry = bind_id;
+
+		if (fgets(line, PATH_MAX, bind_list_f) != NULL) {
+			text = rtrim(line);
+			if (strcmp(text, "") != 0)
+				entry->data = strdup(text);
+			else
+				entry->data = NULL;
+		}
+		else {
+			free (bind_id);
+			bind_id = NULL;
+		}
+
+		while(fgets(line, PATH_MAX, bind_list_f) != NULL) {
+			text = rtrim(line);
+			if (entry->data != NULL) {
+				entry->next = malloc (sizeof(*entry));
+				entry = entry->next;
+			}
+			if (strcmp(text, "") != 0)
+				entry->data = strdup(text);
+			else
+				entry->data = NULL;
+		}
+		fclose (bind_list_f);
+
+		entry->next = NULL;
+	}
+	else {
+		return;
+	}
+
+	copy = entry = bind_id;
+	copy = entry == NULL ? NULL : entry->next;
+
+	if (entry != NULL && strcmp(entry->data, id) == 0) {
+		bind_id = copy;
+		entry = bind_id;
+	}
+
+	while (entry != NULL && entry->data != NULL && copy != NULL) {
+		if (strcmp(copy->data, id) == 0) {
+			entry->next = copy->next;
+		}
+		if (copy->next) {
+			copy = copy->next;
+			entry = entry->next;
+		}
+		else
+			break;
+	}
+
+	if (bind_id == NULL || bind_id->data == NULL) {
+		if (unlink(BIND_LIST) != 0) {
+			perror("Couldn't remove empty bind list file");
+		}
+		return;
+	}
+
+	if ((bind_list_f = fopen (BIND_LIST, "w")) != NULL) {
+
+		entry = bind_id;
+		while (entry != NULL && entry->data != NULL) {
+			fprintf(bind_list_f, "%s\n", entry->data);
+			entry = entry->next;
+		}
+		fclose(bind_list_f);
+	}
+	else
+		perror("Couldn't open bind list for writing");
+
+	free_list(bind_id);
+	return;
+}
+
+int add_to_list (char* name, char *id)
+{
+	char *list_file, *line;
+	char buffer[PATH_MAX];
+	struct list_entry *bind_id, *entry;
+	struct stat buf;
+	FILE *rc;
+	int ret_val;
+
+	ret_val = 0;
+
+	asprintf(&list_file, "/var/lib/usb_modeswitch/%s", name);
+
+	bind_id = malloc (sizeof(*bind_id));
+	bind_id->data = NULL;
+	bind_id->next = NULL;
+
+	if (strcmp(name, "bind_list") == 0 &&
+			stat(BIND_LIST, &buf) == 0 &&
+			stat(list_file, &buf) == 0) {
+		if (rename(BIND_LIST, list_file) == -1) {
+			perror ("Error renaming the old bind list file");
+			ret_val = -1;
+			goto out;
+		}
+	}
+
+	entry = bind_id;
+	if (stat(list_file, &buf) == 0) {
+		rc = fopen (list_file, "r");
+		while (fgets(buffer, PATH_MAX, rc) != NULL) {
+			entry->data = NULL;
+			entry->next = NULL;
+			line = strdup(rtrim(buffer));
+			if (strcmp(line, "") == 0)
+				continue;
+			if (strcmp(line, id) == 0) {
+				// go to out, for cleanup and to return.
+				ret_val = -1;
+				goto out;
+			}
+			entry->data = line;
+			entry->next = malloc (sizeof(*entry));
+			entry = entry->next;
+		}
+		fclose(rc);
+		rc = NULL;
+	}
+	entry->data = strdup(id);
+	entry->next = NULL;
+
+	if ((rc = fopen (list_file, "w")) != NULL) {
+		entry = bind_id;
+		while(entry != NULL && entry->data != NULL) {
+			fprintf(rc, "%s\n", entry->data);
+			entry = entry->next;
+		}
+		ret_val = 1;
+		fclose(rc);
+		rc = NULL;
+	}
+	else
+		perror("Couldn't open bind list for writing");
+
+out:
+	if (rc)
+		fclose(rc);
+	free_list(bind_id);
+	free(list_file);
+	return ret_val;
+}
+
+int in_bind_list (char *id)
+{
+	FILE *bind_list;
+	char buffer[PATH_MAX];
+	char *line;
+	int ret_val;
+
+	if((bind_list = fopen(BIND_LIST, "r")) == NULL) {
+		perror("Unable to open bind list file");
+		return 0;
+	}
+
+	ret_val = 0;
+	while (fgets(buffer, PATH_MAX, bind_list) != NULL) {
+		line = strdup(rtrim(buffer));
+		if (strcmp(line, "") == 0)
+			continue;
+		if (strcmp(line, id) == 0) {
+			ret_val = 1;
+			goto out;
+		}
+	}
+
+out:
+	fclose(bind_list);
+
+	if (ret_val)
+		modeswitch_log("Found %s in bind_list\n", id);
+	else
+		modeswitch_log("No %s in bind_list\n", id);
+
+	return ret_val;
+}
+
+void modeswitch_log(const char* format, ...)
+{
+	char *logfile_name;
+	time_t now;
+	va_list args;
+
+	if (logging == 0)
+		return;
+
+	if (logfile == NULL) {
+		//sprintf(logfile_name, "%s%s", LOGFILE_TEMPL, device);
+		/* short-circuit temporarily to write to a single log file. */
+		asprintf(&logfile_name, "%s", LOGFILE_TEMPL);
+		if ((logfile = fopen(logfile_name, "w")) != NULL) {
+			time(&now);
+			fprintf(logfile, "\n\nUSB_ModeSwitch log from %s\n", ctime(&now));
+		}
+		else {
+			logging = 0;
+			perror(logfile_name);
+			return;
+		}
+	}
+
+	if (logfile != NULL) {
+		va_start(args, format);
+		vfprintf(logfile, format, args);
+		va_end(args);
+		fflush(logfile);
+	}
+
+	return;
+}
+
+void read_attrs(char *subsystem, struct dev_attr **dev_type, char **attr_list, char *dir)
+{
+	FILE *rc;
+	char value[PATH_MAX];
+	char *attr_path;
+	int i;
+
+	if (access(dir, X_OK) == 0)
+		modeswitch_log("\n%s dir exists: %s\n", subsystem, dir);
+
+	for (i = 0; attr_list[i] != NULL; i++) {
+		asprintf(&attr_path, "%s/%s", dir, attr_list[i]);
+		dev_type[i] = malloc(sizeof(**dev_type));
+		dev_type[i]->attr = attr_list[i];
+		if ((rc = fopen(attr_path, "r")) != NULL) {
+			if (fgets(value, PATH_MAX, rc) != NULL) {
+				dev_type[i]->value = strdup(rtrim(value));
+			}
+			else {
+				dev_type[i]->value = 0;
+				modeswitch_log("Warning: %s attribute %s not found.\n", subsystem, attr_list[i]);
+			}
+			fclose(rc);
+		}
+		else {
+			dev_type[i]->value = 0;
+			modeswitch_log("Warning: %s attribute \"%s\" not readable.\n", subsystem, attr_list[i]);
+			perror("Could not read attribute");
+		}
+		free(attr_path);
+	}
+
+	return;
+}
+
+void read_scsi_attrs(char *dir)
+{
+	read_attrs("SCSI", scsi, (char **) scsi_attrs, dir);
+
+	return;
+}
+
+void read_usb_attrs(char* dir)
+{
+	read_attrs("USB", usb, (char **) usb_attrs, dir);
+
+	return;
+}
+
+void config_get_list(char *config_name)
+{
+	char **config_list;
+	pipeline *p;
+	const char *line;
+	char *config_path,*dup_line;
+	glob_t config_glob;
+	int i, j, glob_status;
+
+	// TODO: factor out to main or parse_global_config
+	if (config.config_pack_path == NULL) {
+		asprintf(&config.config_pack_path, "%s/%s", DB_DIR, CONFIG_PACK_NAME);
+	}
+	// -----------------------
+
+	/*
+	 * XXX: not quite the same functionality as the original, but it will do for now:
+	 * 		until there's a better way, append to the list and make sure the last entries
+	 * 		override previous ones when comes the time to read files. This way, we can read
+	 * 		the list from the tarball, override with files outside of it if some are shipped
+	 * 		(or if the tarball doesn't exist), and retain the possibility of overriding any
+	 * 		such config file with user-written configs from /etc/usb_modeswitch.d
+	 */
+	config_list = NULL;
+
+	i = 0;
+	config_list = realloc(config_list, sizeof(*config_list) * (i + 1) + sizeof(NULL));
+	if (access(config.config_pack_path, F_OK) == 0) {
+		modeswitch_log("Found packed config collection %s\n", config.config_pack_path);
+
+		p = pipeline_new_command_args ("tar", "-tzf", config.config_pack_path, NULL);
+		pipeline_want_out (p, -1);
+		pipeline_start (p);
+		line = pipeline_readline(p);
+		dup_line = strdup(line);
+		if (line != NULL) {
+			config_list[0] = strdup(rtrim(dup_line));
+			i++;
+		}
+		free(dup_line);
+
+		while ((line = pipeline_readline(p)) != NULL) {
+			dup_line = strdup(line);
+			config_list = realloc(config_list, sizeof(*config_list) * (i + 1) + sizeof(NULL));
+			config_list[i] = strdup(rtrim(dup_line));
+			free(dup_line);
+			i++;
+		}
+		pipeline_free(p);
+	}
+
+	// Fallback to looking for single files in the db directories
+	// ... or use extra files to override shipped configurations.
+	asprintf(&config_path, "%s/%s*", DB_DIR, config_name);
+	modeswitch_log("Searching entries named: %s\n", config_path);
+
+	glob_status = glob(config_path, 0, NULL, &config_glob);
+	if (glob_status == 0) {
+		for (j = 0; config_glob.gl_pathv[j] != NULL; j++, i++) {
+			config_list = realloc(config_list, sizeof(*config_list) * (i + 2) + sizeof(NULL));
+			config_list[i] = strdup(basename(config_glob.gl_pathv[j]));
+		}
+		globfree(&config_glob);
+	}
+	else if (glob_status == GLOB_NOMATCH) {
+		globfree(&config_glob);
+		// try again, with the /etc/ directory now.
+		sprintf(config_path, "%s/%s*", DB_ETCDIR, config_name);
+		modeswitch_log("Searching overriding entries named: %s\n", config_path);
+
+		glob_status = glob(config_path, 0, NULL, &config_glob);
+		if (glob_status == 0) {
+			for (j = 0; config_glob.gl_pathv[j] != NULL; j++, i++) {
+				config_list = realloc(config_list, sizeof(*config_list) * (i + 2) + sizeof(NULL));
+				config_list[i] = strdup(basename(config_glob.gl_pathv[j]));
+			}
+			globfree(&config_glob);
+		}
+		else
+			globfree(&config_glob);
+	}
+	else {
+		modeswitch_log("Error: glob error\n");
+	}
+	config_list[i] = NULL;
+
+	config.config_list = config_list;
+
+	free(config_path);
+
+	return;
+}
+
+char* config_get_config(char *config_name)
+{
+	FILE *tmpconf;
+	char *config_path, *etc_config_path;
+	const char *line;
+	pipeline *p;
+
+	asprintf(&config_path, "%s/%s", DB_DIR, config_name);
+	asprintf(&etc_config_path, "%s/%s", DB_ETCDIR, config_name);
+
+	// Overriding from /etc/ or flat files in /usr/share
+	if (access(etc_config_path, F_OK) == 0) {
+		modeswitch_log("Using overriden config %s from collection %s\n", config_name, DB_ETCDIR);
+		config.device_config = strdup(etc_config_path);
+	}
+	else if (access(config_path, F_OK) == 0) {
+		modeswitch_log("Using overriden config %s from collection %s\n", config_name, DB_DIR);
+		config.device_config = strdup(config_path);
+	}
+	else if (access(config.config_pack_path, F_OK) == 0) {
+		config.device_config = strdup(DEFAULT_TMPCONFIG);
+		modeswitch_log("Extracting config %s from collection %s\n", config_name, config.config_pack_path);
+		tmpconf = fopen(config.device_config, "w");
+		if (!tmpconf) {
+			perror("Could not open temporary config file for writing");
+			free(config.device_config);
+			config.device_config = NULL;
+			goto out;
+		}
+		p = pipeline_new_command_args ("tar", "-xzOf", config.config_pack_path, config_name, NULL);
+		pipeline_want_out (p, -1);
+		pipeline_start (p);
+		while ((line = pipeline_readline(p)) != NULL) {
+			fprintf(tmpconf, "%s", line);
+		}
+		pipeline_free(p);
+		fclose(tmpconf);
+	}
+	else {
+		modeswitch_log("Could not determine or load a usable configuration file.\n");
+		config.device_config = NULL;
+	}
+
+out:
+	free(config_path);
+	free(etc_config_path);
+
+	return config.device_config;
+}
+
+int match_device(char *config_name)
+{
+	char **info_list;
+	char *cname, *info;
+	char *token, *attr, *value;
+	struct dev_attr **match_tmp, **system;
+	int i, j, idx, ret_val;
+
+	ret_val = 0;
+
+	/* skip if config_name is a file left around by a package manager */
+	if (strstr(config_name, ".dpkg") != NULL ||
+            strstr(config_name, ".rpm") != NULL)
+		return ret_val;
+
+	cname = strdup(config_name);
+
+	info_list = NULL;
+	match_tmp = NULL;
+
+	token = strtok(cname, ":");
+	if (token != NULL) {
+		info_list = realloc(info_list, sizeof(*info_list));
+		info_list[0] = token;
+	}
+
+	i = 1;
+	while ((token = strtok(NULL, ":")) != NULL) {
+		info_list = realloc(info_list, sizeof(*info_list) * (i+2) + sizeof(NULL));
+		info_list[i] = token;
+		i++;
+	}
+	info_list[i] = NULL;
+
+	if (info_list[0] == NULL || info_list[1] == NULL) {
+		ret_val = 0;
+		goto out;
+	}
+
+	if (info_list[2] == NULL) {
+		if (strcmp(info_list[0], usb[idVendor]->value) == 0 &&
+			strcmp(info_list[1], usb[idProduct]->value) == 0)
+		ret_val = 1;
+		goto out;
+	}
+
+	token = NULL;
+	i = 2;
+	j = 0;
+
+	while (info_list[i] != NULL) {
+		info = strdup(info_list[i]);
+
+		if (strcmp(info_list[i], "?") == 0) {
+			ret_val = 0;
+			goto out;
+		}
+
+		match_tmp = realloc(match_tmp, sizeof(*match_tmp) * (j+1) + sizeof(NULL));
+
+		attr = strdup(strtok(info, "="));
+		value = strdup(strtok(NULL, "="));
+		match_tmp[j] = malloc(sizeof(**match_tmp));
+		match_tmp[j]->attr = attr;
+
+		if (value != NULL) {
+			match_tmp[j]->value = value;
+		}
+		else {
+			match_tmp[j]->value = strdup("");
+		}
+
+		free(info);
+		i++;
+		j++;
+	}
+	match_tmp[j] = NULL;
+
+	for(i = 0; match_tmp[i] != NULL; i++) {
+		modeswitch_log("matching %s\n", match_tmp[i]->attr);
+		modeswitch_log("  match string: %s\n", match_tmp[i]->value);
+
+		if (match_tmp[i]->attr[0] == 's')
+			system = scsi;
+		else if (match_tmp[i]->attr[0] == 'u')
+			system = usb;
+
+		if (strcmp(match_tmp[i]->attr, "uMa") == 0)
+			idx = uMa;
+		else if (strcmp(match_tmp[i]->attr, "uPr") == 0)
+			idx = uPr;
+		else if (strcmp(match_tmp[i]->attr, "uSe") == 0)
+			idx = uSe;
+		else if (strcmp(match_tmp[i]->attr, "sVe") == 0)
+			idx = sVe;
+		else if (strcmp(match_tmp[i]->attr, "sMo") == 0)
+			idx = sMo;
+		else if (strcmp(match_tmp[i]->attr, "sRe") == 0)
+			idx = sRe;
+
+		modeswitch_log(" device string: %s\n", system[idx]->value);
+		if (system[idx]->value != NULL) {
+			if (strstr(system[idx]->value, match_tmp[i]->value) == 0)
+				break;
+		}
+	}
+
+	//printf("match/j: %d/%d\n", match, j);
+	if (match_tmp[i] == NULL) {
+		ret_val = 1;
+	}
+
+out:
+	for (i = 0; match_tmp != NULL && match_tmp[i] != NULL; i++) {
+		free(match_tmp[i]->attr);
+		free(match_tmp[i]->value);
+	}
+
+	free(info_list);
+	free(cname);
+
+	return ret_val;
+}
Index: usb-modeswitch/Makefile
===================================================================
--- usb-modeswitch.orig/Makefile	2011-08-09 12:33:58.668466682 -0400
+++ usb-modeswitch/Makefile	2011-08-09 12:39:05.029374559 -0400
@@ -10,20 +10,27 @@
 UDEVDIR     = $(DESTDIR)/lib/udev
 SBINDIR     = $(PREFIX)/sbin
 MANDIR      = $(PREFIX)/share/man/man1
+DISPATCHER_PROG = usb_modeswitch_dispatcher
+DISPATCHER_OBJS = usb_modeswitch_dispatcher.c
+DISPATCHER_LIBS = -lpipeline -ludev
 
 .PHONY:    clean install uninstall
 
-all:        $(PROG)
+all:        $(PROG) $(DISPATCHER_PROG)
 
 $(PROG): $(OBJS)
 	$(CC) -o $(PROG) $(OBJS) $(CFLAGS) $(LIBS) $(LDFLAGS)
 
+$(DISPATCHER_PROG): $(DISPATCHER_OBJS)
+	$(CC) -o $(DISPATCHER_PROG) $(DISPATCHER_OBJS) $(CFLAGS) $(DISPATCHER_LIBS) $(LDFLAGS)
+
 clean:
 	$(RM) usb_modeswitch
+	$(RM) usb_modeswitch_dispatcher
 
 install: all
 	install -D -s --mode=755 usb_modeswitch $(SBINDIR)/usb_modeswitch
-	install -D --mode=755 usb_modeswitch.tcl $(SBINDIR)/usb_modeswitch_dispatcher
+	install -D --mode=755 usb_modeswitch_dispatcher $(SBINDIR)/usb_modeswitch_dispatcher
 	install -D --mode=755 usb_modeswitch.sh $(UDEVDIR)/usb_modeswitch
 	install -D --mode=644 usb_modeswitch.conf $(ETCDIR)/usb_modeswitch.conf
 	install -D --mode=644 usb_modeswitch.1 $(MANDIR)/usb_modeswitch.1
@@ -31,6 +38,7 @@
 
 uninstall:
 	$(RM) $(SBINDIR)/usb_modeswitch
+	$(RM) $(SBINDIR)/usb_modeswitch_dispatcher
 	$(RM) $(UDEVDIR)/usb_modeswitch
 	$(RM) $(ETCDIR)/usb_modeswitch.conf
 	$(RM) $(MANDIR)/usb_modeswitch.1
